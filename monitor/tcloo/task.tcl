# -- task.tcl
#
#

package require TclOO
package require ngis::conf
package require ngis::msglogger
package require ngis::taskmessages

catch { ::ngis::Task destroy }

namespace eval ::ngis::tasks {
    variable tasks      [list untested congruence      connectivity capabilities capabilities2]
    variable procedures [list start    data_congruence http_status  get_url      run_bash]
    variable functions  [list ""       ""              ""           ""           readurl]
    variable taskn      -1

    # throughout this code we assume that every task description dictionary
    # is generated by this procedure. This namespace will be endowed with
    # the methods (procedures) needed to properly handle such dictionaries.
    # We don't want to create full fledged oo objects because thread workers
    # are designed to handle tasks, but such ojects cannot be shared among
    # threads lest the classes are (uselessly?) endowed with serialization/
    # deserialization methods

    proc mktask {t job_o} {
        variable tasks
        variable procedures
        variable functions

        set task_id [lsearch $::ngis::tasks::tasks $t]
        if {$task_id >= 0} {
            #return [::ngis::Task create ::ngis::Task[incr ::ngis::tasks::taskn] [lindex $tasks $task_id]]
            set job_d [$job_o serialize]
            dict unset job_d tasks
            return [dict create task        [lindex $tasks $task_id]        \
                                procedure   [lindex $procedures $task_id]   \
                                function    [lindex $functions $task_id]    \
                                status      "" \
                                data        "" \
                                job         $job_d]
        }
        return -code 1 -errorcode invalid_task
    }

    proc job_name {task_d} {
        return [dict get $task_d job jobname]
    }

    proc url {task_d} { return [dict get $task_d job uri] }
    namespace export   *
    namespace ensemble create
}

::oo::class create ::ngis::Task {
    variable next
    variable previous
    variable task
    variable procedure
    variable function
    variable task_data
    variable status

    constructor {t} {
        set tindex [lsearch $::ngis::tasks::tasks $t]
        if {$tindex < 0} { return -code 1 -errorcode task_not_found }

        set task        $t
        set procedure   [lindex $::ngis::tasks::procedures $tindex]
        set function    [lindex $::ngis::tasks::functions  $tindex]
        set next        DONE
        set prev        ""
        set status      ""
    }

    method serialize {} {
        return [list task $task procedure $procedure function $function status $status]
    }

    method deserialize {task_l} {
        foreach f [list task procedure function status] {

        }
    }

    method exit_status {} { return $status }

    method function {} { return $function }
    method name {} { return $task }
    method set_previous {p} { set previous $p }
    method set_next {n} { set next $n }

    method next {} { return $next }
    method previous {} { return $previous }
    method get_tasks {} { return $::ngis::tasks::tasks }

    method run {job_o} {
        ::ngis::logger emit "running procedure '$procedure' (function '$function') for job [$job_o jobname]"

        if {[catch {set status [::ngis::procedures::${procedure} $job_o $function]} e einfo]} {
            set status [::ngis::tasks::make_error_result [$job_o jobname] $e [dict get $einfo -errorcode] ""]
        }
        return $status
    }
}

#namespace eval ::ngis::tasks {
#
#    proc mktask {t {url ""}} {
#        variable tasks
#        variable procedures
#        variable functions
#
#        set task_id [lsearch $::ngis::tasks::tasks $t]
#        if {$task_id >= 0} {
#            #return [::ngis::Task create ::ngis::Task[incr ::ngis::tasks::taskn] [lindex $tasks $task_id]]
#            return [dict create task        [lindex $tasks $task_id] \
#                                procedure   [lindex $procedures $task_id] \
#                                function    [lindex $functions $task_id] \
#                                url         $url \
#                                status      ok \
#                                data        ""]
#        }
#        return -code 1 -errorcode invalid_task
#    }
#
#}

package provide ngis::task 0.3
