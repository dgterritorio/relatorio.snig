# -- task.tcl
#
#

package require ngis::conf
package require ngis::msglogger
package require ngis::taskmessages

namespace eval ::ngis::tasks {
    #variable base_tasks [list congruence     ]
    #variable procedures [list data_congruence]
    #variable functions  [list ""             ]
    #variable descriptions [list "Data congruence"]
                                #"Analyze service HTTP/HTTPS response" \
                                #"Test service by checking response to HTTP requests (using Tcl's http package)" \
                                #"Curl based determination of capabilities"
    variable tasks      [list]
    variable tasks_db   [dict create]

    # throughout the whole code we assume that every task description
    # dictionary is generated by this procedure. This namespace will be endowed with
    # the methods (procedures) needed to properly handle such dictionaries.

    # We don't want to create full-fledged oo objects because thread workers
    # are designed to handle tasks and such objects couldn't be shared among
    # threads lest the classes are (uselessly?) endowed with serialization/
    # deserialization methods

    proc mktask {t job_o {t_args ""}} {
        variable tasks_db
        variable tasks

        if {[dict exists $tasks_db $t]} {
            set job_d [$job_o serialize]
            dict unset job_d tasks

            set task_d [dict get $tasks_db $t]

            dict set task_d task   $t
            dict set task_d status ""
            dict set task_d data   ""
            dict set task_d args   ""
            dict set task_d job    $job_d
            return $task_d
        }
        return -code 1 -errorcode invalid_task
    }

    proc get_registered_tasks {} {
        variable tasks
        return $tasks
    }

    proc get_task {task} {
        variable task_db
        if {[dict exists $task_db $task]} {
            return [dict get $task_db $task]
        }
        return -code error -errorcode unregistered_task "Unregistered task '$task'"
    }

    # -- Data access methods
    #
    # we don't check the consistence of the dictionary. If a key is
    # missing there's a problem in the caller's code and it rightfully
    # must generated an error

    proc job_name {task_d} { return [dict get $task_d job jobname] }
    proc url {task_d} { return [dict get $task_d job uri] }
    proc gid {task_d} { return [dict get $task_d job gid] }
    proc uuid {task_d} { return [dict get $task_d job uuid] }
    proc type {task_d} { return [dict get $task_d job uri_type] }
    proc version {task_d} { return [dict get $task_d job version] }
    proc procedure {task_d} { return [dict get $task_d procedure] }
    proc function {task_d} { return [dict get $task_d function] }
    proc script {task_d} { return [dict get $task_d script] }
    proc language {task_d} { return [dict get $task_d language] }

    proc build_tasks_database {path_list} {
        variable tasks
        variable tasks_db
        #variable base_tasks
        #variable procedures
        #variable functions
        #variable descriptions

        #set tasks_db [dict create]
        #set tasks $base_tasks
        #foreach bt $base_tasks btp $procedures btf $functions btd $descriptions {
        #    dict set tasks_db $bt [dict create  function    $btf \
        #                                        procedure   $btp \
        #                                        description $btd]
        #}

        foreach p $path_list {
            set glist [glob [file join $p "*"]]

            foreach script [lsort $glist] {
                puts "analyze script: $script"
                if {[catch {
                    set ftype [file extension $script]
                    if {$ftype == ".sh"} {

                        set identify [exec /bin/bash $script identify]
                        set language "Bash"
                        set procedure "run_bash"
                        set function $script

                        lassign $identify task uri_type description
                    } elseif {$ftype == ".tcl"} {

                        namespace eval [namespace current] [list source $script ]
                        set identify [eval [namespace current]::identify]
                        set language "Tcl"
                        set procedure "run_tcl"
                        lassign $identify task uri_type function description

                        rename [namespace current]::${function} ""
                    }

                    lappend tasks $task
                    dict set tasks_db $task [dict create function    $function  \
                                                         script      $script    \
                                                         description $description \
                                                         uri_type    $uri_type  \
                                                         procedure   $procedure \
                                                         language    $language]
                } e einfo]} {
                    ::ngis::logger emit "error analyzing shell script $script: $e $einfo"
                    continue
                }
            }

            catch {rename [namespace current]::identify ""}
        }
    }

    proc list_registered_tasks {} {
        variable tasks
        variable tasks_db

        set tasks_l [lmap t $tasks { 
            set td [dict get $tasks_db $t]
            dict with td {
                set tlist [list $t $uri_type $function $description $procedure $script $language] 
            }
            set tlist
        }]
        return $tasks_l
    }

    namespace export   *
    namespace ensemble create
}

package provide ngis::task 0.3
