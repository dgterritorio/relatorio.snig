# -- task.tcl
#
#

package require ngis::conf
package require ngis::msglogger
package require ngis::taskmessages

namespace eval ::ngis::tasks {
    variable base_tasks [list congruence      connectivity capabilities capabilities2]
    variable procedures [list data_congruence http_status  get_url      run_bash]
    variable functions  [list ""              ""           ""           readurl]
    variable descriptions [list "Testing resource record data completeness and congruence" \
                                "Analyze service HTTP/HTTPS response" \
                                "Test service by checking response to HTTP requests (using Tcl's http package)" \
                                "Curl based determination of capabilities"]
    variable tasks      [list]
    variable tasks_db   [dict create]

    # throughout the monitor code we assume that every task description
    # dictionary is generated by this procedure. This namespace will be endowed with
    # the methods (procedures) needed to properly handle such dictionaries.

    # We don't want to create full-fledged oo objects because thread workers
    # are designed to handle tasks and such objects couldn't be shared among
    # threads lest the classes are (uselessly?) endowed with serialization/
    # deserialization methods

    proc mktask {t job_o {t_args ""}} {
        variable tasks
        variable procedures
        variable functions

        set task_id [lsearch $::ngis::tasks::tasks $t]
        if {$task_id >= 0} {
            set job_d [$job_o serialize]
            dict unset job_d tasks
            return [dict create task        [lindex $tasks $task_id]        \
                                procedure   [lindex $procedures $task_id]   \
                                function    [lindex $functions $task_id]    \
                                status      "" \
                                data        "" \
                                args        "" \
                                job         $job_d]
        }
        return -code 1 -errorcode invalid_task
    }

    proc get_registered_tasks {} {
        variable tasks
        return $tasks
    }

    # -- Data access methods
    #
    # we don't check the consistence of the dictionary. If a key is
    # missing there's a problem in the caller's code and it rightfully
    # must generated an error

    proc job_name {task_d} { return [dict get $task_d job jobname] }
    proc url {task_d} { return [dict get $task_d job uri] }

    proc build_tasks_database {path_list} {
        variable tasks
        variable tasks_db
        variable base_tasks
        variable procedures
        variable function
        variable descriptions

        set tasks $base_tasks
        foreach bt $base_tasks btp $procedures btf $functions btd $descriptions {
            dict set tasks_db $bt [dict create  function    $btf \
                                                procedure   $btp \
                                                description $btd]
        }

        foreach p $path_list {
            set glist [glob [file join $p "*.sh"]]

            foreach shscript $glist {
                if {[catch {
                    set identity [exec /bin/bash $shscript identify]
                } e einfo]} {
                    ::ngis::logger emit "error analyzing shell script $shscript: $e $einfo"
                    continue
                }

                lassign identity task description

                lappend tasks $task
                dict set tasks_db $task [dict create function    $shscript \
                                                     description $description \
                                                     procedure   run_bash]
            }
        }
    }

    namespace export   *
    namespace ensemble create
}

package provide ngis::task 0.3
