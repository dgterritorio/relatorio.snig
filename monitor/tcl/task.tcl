# -- task.tcl
#
#

package require ngis::conf
package require ngis::msglogger
package require ngis::taskmessages

namespace eval ::ngis::tasks {
    variable verbose true

    variable tasks      [list]
    variable tasks_db   [dict create]

    # throughout the whole code we assume that every task description
    # dictionary is generated by this procedure. This namespace will be endowed with
    # the methods (procedures) needed to properly handle such dictionaries.

    # We don't want to create full-fledged oo objects because thread workers
    # are designed to handle tasks and such objects couldn't be shared among
    # threads lest the classes are (uselessly?) endowed with serialization/
    # deserialization methods

    proc mktask {t} {
        variable tasks_db
        variable tasks

        if {[dict exists $tasks_db $t]} {
            set task_d [dict get $tasks_db $t]
            dict set task_d task   $t
            dict set task_d status ""
            dict set task_d data   ""
            dict set task_d args   ""
            return $task_d
        }
        return -code 1 -errorcode invalid_task
    }

    proc get_registered_tasks {} {
        variable tasks
        return $tasks
    }

    proc get_task {task} {
        variable tasks_db
        if {[dict exists $tasks_db $task]} {
            return [dict get $tasks_db $task]
        }
        return -code error -errorcode unregistered_task "Unregistered task '$task'"
    }

    proc get_tasks_db {} {
        variable tasks_db
        return $tasks_db
    }

    # -- Data access methods
    #
    # we don't check the consistence of the dictionary. If a key is
    # missing there's a problem in the caller's code and it rightfully
    # must generated an error

    proc job_name {task_d} { return [dict get $task_d job jobname] }
    proc url {task_d} { return [dict get $task_d job uri] }
    proc gid {task_d} { return [dict get $task_d job gid] }
    proc uuid {task_d} { return [dict get $task_d job uuid] }
    proc type {task_d} { return [dict get $task_d job uri_type] }
    proc version {task_d} {
        if {[dict exists $task_d job version]} {
            return [dict get $task_d job version]
        } else {
            return "<unspecified>"
        }
    }
    proc procedure {task_d} { return [dict get $task_d procedure] }
    proc function {task_d} { return [dict get $task_d function] }
    proc script {task_d} { return [dict get $task_d script] }
    proc language {task_d} { return [dict get $task_d language] }

    proc term_output {str} {
        variable verbose 

        if {[string is true $verbose]} {
            puts $str
        }
    }

    proc build_tasks_database {task_path_dir args} {
        variable tasks
        variable tasks_db
        variable verbose

        set verbose true
        foreach a $args {
            if {$a == "-verbose"} {
                set verbose true
            } elseif {$a == "-quiet"} {
                set verbose false
            } else {
                puts "unrecognized option '$a'"
            }
        }

        # save current_dir to be restored
        set glist [glob [file join $task_path_dir "*"]]
        foreach script [lsort $glist] {
            term_output "analyze script: $script"
            if {[catch {
                set ftype [file extension $script]
                if {$ftype == ".sh"} {
                    set identity [exec /bin/bash $script identify]
                    lassign $identity task description
                    lappend tasks $task
                    dict set tasks_db $task [dict create function    $script \
                                                         script      $script \
                                                         description $description \
                                                         procedure   run_bash \
                                                         language    "Bash"]
                } elseif {$ftype == ".tcl"} {

                    #puts "ns: [namespace current]"
                    namespace eval [namespace current] [list source $script ]
                    set identity [eval [namespace current]::identify]
                    lassign $identity task function description
                    lappend tasks $task
                    dict set tasks_db $task [dict create function    $function \
                                                         script      $script \
                                                         description $description \
                                                         procedure   run_tcl \
                                                         language    "Tcl"]
                    rename [namespace current]::${function} ""
                }
            } e einfo]} {
                ::ngis::logger emit "error analyzing shell script $script: $e $einfo"
                continue
            }
        }
        catch {rename [namespace current]::identify ""}
        return
    }

    proc list_registered_tasks {{tasks_l "-all"}} {
        variable tasks
        variable tasks_db

        if {$tasks_l == "--all"} {
            set tasks_l $tasks
        }

        set task_descriptors_l [lmap t $tasks_l {
            set td [dict get $tasks_db $t]
            dict with td {
                set tlist [list $t $procedure $description [file tail $script] $language]
            }
            set tlist
        }]
        return $task_descriptors_l
    }

    proc list_tasks {{task_selection_l "--all"}} {
        variable tasks
        variable tasks_db

        # we can't rely on 'dict filter' because we actually need
        # an ordered list of key-value lists
        if {$task_selection_l == "--all"} {
            set task_selection_l $tasks
        }
        return [lmap t $task_selection_l {
            dict get $tasks_db $t
        }]
    }

    namespace export   *
    namespace ensemble create
}

package provide ngis::task 1.0
